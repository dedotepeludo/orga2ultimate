\section{Desarrollo}

\begin{enumerate}
\item \textsc{generarFondo}:
Como primera funci'on a reescribir en \textbf{MMX} demor'o unas cuantas pasadas hasta
dejarnos conformes con el resultado, cumpliendo as'i con su rol de debut.
Utilizar registros mmx como banco de memoria para no utilizar variables locales
fue una de las habilidades adquiridas aqu'i, adem'as de aprender a dividir el
procesamiento paralelamente explotando las posiblidades que nos brinda
\textbf{MMX}.

Para este tp logramos una renovada y casi dir'ia revolucionaria forma de
calcular el resto de dividir por $4$, cosa que necesitamos apra calccular la
basura. En lugar de dividir hacemos un \textsc{and} de\textbf{0x3} con el
n'umero y eso nos da el resto de dividir por $4$. Luego le restamos esto a 4
para obtener la basura a menos que el resto sea 0 donde no tenemos basura.

El piso lo procesamos de forma lineal, en lugar de pintar cuadrado por cuadrado
lo pintamos directo sobre el buffer de salida.

\item \textsc{recortar}:
En esta funci'on calculamos la basura de la imagen para saber cuanto tenemos
que avanzar por fila y la basura que le correspond�a al sprite para pasarla al
resultado. Mucha mas ciencia no requiri'o que pasar de a 8 bytes usando mmx.

\item \textsc{blit}:

Para esta funci'on nos generamos 2 m'ascaras con el fucsia. Para procesar 2
pixeles con \textbf{MMX} utilizamos una m'ascara con los 3 bytes alineados al
centro de la forma \textbf{0x00FF00FFFF00FF00}. La m'ascara para procesar de a
un p'ixel en los extremos es \textbf{0xFF00FF00}, este p'ixel esta alineado
sobre la parte alta del registro.

La idea de alinear al centro los 2 p'ixeles al procesar en \textbf{MMX} surgi'o
con la idea de poder realizar operaciones con 2 dword y que cada resultado 
le corresponda a un p'ixel distintdo. 

Aqu'i tambi'en calculamos la basura de la imagen para sumarla cuando terminamos
de procesar cada fila al puntero y as'i apuntar al inicio de la siguiente fila.
En el ciclo de \textbf{MMX} centramos los 2 p'ixeles y los comparamos con el fucsia.
Usando un \textsc{PANDN} con el resultado de la comparaci'on y los p'ixeles centrados
colocamos 0 donde hab'ia fucsia y el color que hab'ia antes en el otro caso.
Acomodamos los pixeles y los volvemos a guardar, volviendo a colocar los
valores que no nos correspond�a procesar.

\item \textsc{chequearColisiones}:
En esta funci'on no utilizamos ninguna mascara pre definida. En cada iteraci'on
procesamos por sprite. Teniendo en cuenta que los rect'angulos con los que
'ibamos a trabajar est'an alineados al eje de coordenada, pudimos simplificarnos
un poco los c'alculos, tomar los valores que son iguales como uno solo y
dividirnos al calcular los rect'angulos con base alineada al eje X y los de base
alineada al eje Y.
Para simplificarnos los calculos y realizar menos renombramos los par'ametros
del sprite:
$$a = xSprite$$
$$b = ySprite$$
$$c = xSprite + wSprite$$
$$d = ySprite + hSprite$$

De acuerdo al orden de los par'ametros nombramos a los tri'angulos como $abc_1$,
$abc_2$, $abc_3$, $abc_4$ con el orden de llegada del punto a.
Para saber el signo del area, el � no nos interesa, entonces lo
ignoramos.<--QUE DICE AC'A????

Nuestras 4 formulas a calcular quedaron:
$$abc1 = a(y_1 - b) + x_1(b - b) + c(b - y_1) = a(y_1 - b) + c(b - y_1)$$
$$abc2 = c(y_1 - d) + x_1(d - b) + c(b - y_1)$$
$$abc3 = c(y_1 - d) + x_1(d - d) + a(d - y_1) = c(y_1 - d) + a(d - y_1)$$
$$abc4 = a(y_1 - b) + x_1(b - d) + a(d - y_1)$$

Primero calculamos $abc_1$ y $abc_3$ y luego $abc_2$ y $abc_4$, ya que estos
'ultimos necesitan de m'as t'erminos. Utilizamos operaciones en words, el
\textbf{PMADDWD} y operaciones en dwords.

Una vez que terminamos con el algoritmo y lo quisimos probar tuvimos problemas
como que no chequeaba correctamente. Despu'es de revisar intensamente el
algoritmo varias veces decidimos verificar la formula del enunciado. Aqu'i nos
encontramos que esta serv'ia para el eje cartesiano com'un, y no para el de la
pantalla, donde el 0 de las Y esta arriba. Probamos varias veces y llegamos a
la conclusi'on que deb'iamos marcar como colisi'on cuando todas las 'areas nos
daban 0 o negativass

Un detalle implementativo fue que nos surgi'o durante el desarrollo de este
algoritmo, fue que el ciclo resulto ser demasiado largo, y el jump para volver
no se declaraba como jump corto, por lo que tuvimos que reemplazarlo por otros
saltos intermedios, curioso.


\item \textsc{generarRayo}:
	Al realizar esta funci'on nos encontramos con el desaf'io de utilizar la
FPU en un programa hecho por nosotros mismos por vez primera. Esto parec'ia
prometedor aunque complicado. Tuvimos que ser muy prolijos al momento de
usarla, cosa que nos cost'o m'as de un dolor de cabeza.

	Para empezar tuvimos que calcular el 'angulo. En un apunte que hizo Emi
dec'ia que para calcularlo deb'iamos hacer
$angulo=seno^{-1}(\frac{opuesto}{tangente})$. Para nosotros donde dice tangente
deber'ia decir hipotenusa. Por otro lado, resulta que $seno^{-1}$ no es 
$\frac{1}{sin}$ sino el $arcsin$.

	Investigando como hacer esto nos encontramos con: ``As you can see, we are
forced to use the ArcSin and ArcCos functions. Unfortunately, the FPU doesn't
have these functions. However, it has the FATAN function, which computes the
ArcTangent. In order to obtain the arcsin and arccos we can use the following
formulas: ArcSin = ArcTan(x/sqrt(1-sqr(x)))''\cite{VLJ}. A pesar de haber
encontrado una forma de resolver el problema, esta misma no nos convenc'ia. Por
lo cual seguimos buscando e investigando. Buscando en la web encontramos una
p'agina de la \cite{WIKI} que hablaba de \textbf{Inverse trigonometric
functions} en la cual hab'ia una secci'on titulada \textbf{Recommended method
of calculation} \cite{WIKITRI}. All'i se puede observar la siguiente
expresi'on:

$$\arcsin x = \arctan \frac{x}{\sqrt{1-x^2}}$$

que dada la existencia de la funci'on de la FPU que calcula el $arctan$, m'as
conocida como \textbf{FPATAN}, decidimos usar esta cuenta, que adem'as verificamos con
otras fuentes su correctitud.

Hasta este punto ten'iamos un rayo de longitud \textbf{tangente}, pero que si
pensabamos al punto $(x_i,y_i)$ como el origen de coordenadas, entonces s'olo
dibujaba en el $1^{er}$ cuadrante, sin importar d'onde estuviera apuntando.
Para solucionar esto hicimos el siguiente razonamiento: supongamos que $\alpha$
es el 'angulo en cuesti'on si est'a en el $1^{er}$ cuadrante, entonces
deb'iamos usar directamente ese. Si est'a en el $2^{do}$ era $angulo = \pi -
\alpha$. Que era el 'angulo llano menos el angulo que representa a la
trayectoria del rayo. Si est'a en el $3^{er}$ cuadrante $angulo = \pi + \alpha$
y en el $4^{to}$ simplemente: $angulo = 2 \times \pi - \alpha$.

Adem'as de esto, vimos que exist'ian muchas expresiones que ibamos a necesitar
calcular muchas veces como ser: $\frac{4\times\pi}{128}$, $40$, $8$. Entonces
estos datos los calculamos inicialmente, o lo cargamos de memoria al comenzar,
y los guardamos en la FPU sin modificarlos para poder usarlos tantas veces como
fuera necesario.

Hicimos una modificaci'on siguiendo los consejos de \textbf{Emi} en la $2^{da}$
vez que calculamos $y$, que fue cambiar un $\times8$ por un $\times4$, para
lograr la dispersi'on deseada del rayo.

Intentamos arreglar tambi'en un problema que ten'ia la funci'on cuando entraba
a la misma con $x_i = x_f$ pero desgraciadamente al cierre de esta edici'on no
lo hab'iamos logrado.

Lo dem'as no tiene mucho m'as para ser resaltado. Salvo que tuvimos algunos
problemas al momento de pintar que se solucionaron haciendolos de otra forma y
no sabemos porque no andaban con el c'odigo original.

\item \textsc{apagar}:
Al igual que anteriormente dejamos los 'ultimos 3 p'ixeles para que se procesen
de a uno. En esta funci'on utilizamos 2 mascaras, una para el fucsia de
\textbf{MMX} y la otra para el procesado simple.

Aqu'i tambi'en calculamos la basura de la imagen para sum'arsela, cuando terminamos
de procesar cada fila, al puntero. As'i apuntamos al inicio de la siguiente fila.

Lo primero que generamos es una mascara con el valor del contador para
completar 0 en R y con el contador en G y B. Como todas las otras mascaras que
utilizamos para procesar en paralelo 2 p'ixeles ubicamos los 3 bytes en el
centro.

En el ciclo de \textbf{MMX} centramos los 2 p'ixeles y los comparamos con el fucsia.
Usamos esta comparaci'on para llenar con el valor anterior donde da igual
(\textbf{PAND}) y llenar con el valor de la mascara con el puntero donde no da
igual (\textbf{PANDN}). Luego, acomodamos los pixeles y los volvemos a guardar
y volvemos a colocar los valores que no nos correspond'ia procesar.
Finalmente restamos al contador 8 y si nos da menor o igual a 0 guardamos 0.

La forma de comparar y guardar los resultados fue evolucionando a medida que
iter'abamos en la confeccii'on de esta funci'on, ya que en un principio
compar'abamos 2 veces, luego hac'iamos una comparaci'on y la neg'abamos
comparandola con 0 y luego se nos encendi'o la lamparita y con una sola
comparaci'on, el \textbf{PAND} y el \textbf{PANDN} nos alcanz'o.

Lo m's dificil fue generar la mascara con el contador de manera correcta.
Adem'as  nos resulto complicado darnos cuenta del orden en que vienen los
pixeles a causa del little endian para luego acomodarlos en el centro de la
mascara. Sin contar con que el \textbf{MOVD} de un registro a \textbf{MMX} nos
jug'o la mala pasada de pisarnos la parte alta.

\end{enumerate}

